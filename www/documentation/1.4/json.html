<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;5.&nbsp;JSON Support</title><link rel="stylesheet" href="https://jersey.dev.java.net/documentation.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Jersey 1.4 User Guide"><link rel="up" href="index.html" title="Jersey 1.4 User Guide"><link rel="prev" href="xml.html" title="Chapter&nbsp;4.&nbsp;XML Support"><link rel="next" href="linking.html" title="Chapter&nbsp;6.&nbsp;Declarative Hyperlinking"><script xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3160303-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;5.&nbsp;JSON Support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="xml.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="linking.html">Next</a></td></tr></table><hr></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" style="float:right"><a href="https://jersey.dev.java.net"><img src="https://jersey.dev.java.net/images/Jersey_yellow.png"></a></div><small xmlns:fo="http://www.w3.org/1999/XSL/Format">Links: <a href="index.html">Table of Contents</a> | <a href="user-guide.html">Single HTML</a></small><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="json"></a>Chapter&nbsp;5.&nbsp;JSON Support</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="json.html#d0e1960">5.1. POJO support</a></span></dt><dt><span class="section"><a href="json.html#d0e1982">5.2. JAXB Based JSON support</a></span></dt><dd><dl><dt><span class="section"><a href="json.html#d0e2015">5.2.1. Configuration Options</a></span></dt><dt><span class="section"><a href="json.html#d0e2056">5.2.2. JSON Notations</a></span></dt><dt><span class="section"><a href="json.html#d0e2464">5.2.3. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="json.html#d0e2475">5.3. Low-Level JSON support</a></span></dt><dd><dl><dt><span class="section"><a href="json.html#d0e2504">5.3.1. Examples</a></span></dt></dl></dd></dl></div><p>Jersey JSON support comes as a set of JAX-RS <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://jsr311.dev.java.net/nonav/releases/1.1/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader</a>
  and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://jsr311.dev.java.net/nonav/releases/1.1/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter</a>
  providers distributed with <span class="emphasis"><em>jersey-json</em></span> module. These providers enable using
  three basic approaches when working with JSON format:

  </p><div class="itemizedlist"><ul type="disc"><li><p><a href="json.html#json.pojo.approach.title">POJO support</a></p></li><li><p><a href="json.html#json.jaxb.approach.title">JAXB based JSON support</a></p></li><li><p><a href="json.html#json.low.level.approach.title">Low-level, JSONObject/JSONArray based JSON support</a></p></li></ul></div><p>
  
  The first method is pretty generic and allows you to map any Java Object to JSON and vice versa. 
  The other two approaches limit you in Java types your resource methods could produce and/or consume.
  JAXB based approach could be taken if you want to utilize certain JAXB features.
  The last, low-level, approach gives you the best fine-grained control over the outcoming JSON data format.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1960"></a>5.1.&nbsp;POJO support</h2></div></div></div><p>
    POJO suppport represents the easiest way to convert your Java Objects to JSON and back.
    It is based on the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jackson.codehaus.org/" target="_top">Jackson library</a>.
    </p><p>
    To switch this method on, you will need to turn <span class="emphasis"><em>JSONConfiguration.FEATURE_POJO_MAPPING</em></span> feature on.
    This could be done in <code class="code">web.xml</code> using the following servlet init parameter:
</p><div class="example"><a name="d0e1976"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;POJO JSON support web.xml configuration</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 
&nbsp;&nbsp;2         &lt;<span class="ReservedWord">init-param</span>&gt;
&nbsp;&nbsp;3             &lt;<span class="ReservedWord">param-name</span>&gt;com.sun.jersey.api.json.POJOMappingFeature&lt;<span class="ReservedWord">/param-name</span>&gt;
&nbsp;&nbsp;4             &lt;<span class="ReservedWord">param-value</span>&gt;true&lt;<span class="ReservedWord">/param-value</span>&gt;
&nbsp;&nbsp;5         &lt;<span class="ReservedWord">/init-param</span>&gt;
&nbsp;&nbsp;6 </pre></div></div><p><br class="example-break">
    
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1982"></a>5.2.&nbsp;JAXB Based JSON support</h2></div></div></div><p>
     Taking this approach will save you a lot of time, if you want to easily produce/consume both JSON and XML data format.
     Because even then you will still be able to use a unified Java model. 
     Another advantage is simplicity of working with such a model, as JAXB leverages annotated POJOs and these could be handled
     as simple Java beans
    </p><p>
     A disadvantage of JAXB based approach could be if you need to work with a very specific JSON format. Then it could be
     difficult to find a proper way to get such a format produced and consumed. This is a reason why a lot of configuration options
     are provided, so that you can control how things get serialized out and deserialized back.
    </p><p>
    Following is a very simple example of how a JAXB bean could look like.
</p><div class="example"><a name="d0e1991"></a><p class="title"><b>Example&nbsp;5.2.&nbsp;Simple JAXB bean implementation</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 @XmlRootElement
&nbsp;&nbsp;2 <span class="ReservedWord">public</span> <span class="ReservedWord">class</span> MyJaxbBean {
&nbsp;&nbsp;3   <span class="ReservedWord">public</span> String name;
&nbsp;&nbsp;4   <span class="ReservedWord">public</span> <span class="ReservedWord">int</span> age;
&nbsp;&nbsp;5       
&nbsp;&nbsp;6   <span class="ReservedWord">public</span> MyJaxbBean() {} <span class="Comment">// JAXB needs this</span>
&nbsp;&nbsp;7 
&nbsp;&nbsp;8   <span class="ReservedWord">public</span> MyJaxbBean(String name, <span class="ReservedWord">int</span> age) {
&nbsp;&nbsp;9     <span class="ReservedWord">this</span>.name = name;
&nbsp;10     <span class="ReservedWord">this</span>.age = age;
&nbsp;11   }
&nbsp;12 }</pre></div></div><p><br class="example-break">
    
    Using the above JAXB bean for producing JSON data format from you resource method, is then as simple as:
    
</p><div class="example"><a name="d0e1997"></a><p class="title"><b>Example&nbsp;5.3.&nbsp;JAXB bean used to generate JSON representation</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 @GET @Produces(<span class="String">"application/json"</span>)
&nbsp;&nbsp;2 <span class="ReservedWord">public</span> MyJaxbBean getMyBean() {
&nbsp;&nbsp;3    <span class="ReservedWord">return</span> <span class="ReservedWord">new</span> MyJaxbBean(<span class="String">"Agamemnon"</span>, 32);
&nbsp;&nbsp;4 }</pre></div></div><p><br class="example-break">
    
    Notice, that JSON specific mime type is specified in @Produces annotation, and the method returns an instance
    of MyJaxbBean, which JAXB is able to process. Resulting JSON in this case would look like:
    
</p><pre class="programlisting">
    {"name":"Agamemnon", "age":"32"}
</pre><p>
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2015"></a>5.2.1.&nbsp;Configuration Options</h3></div></div></div><p>
	JAXB itself enables you to control output JSON format to certain extent. Specifically renaming 
	and ommiting items is easy to do directly using JAXB annotations.
	
	E.g. the following example depicts changes in the above mentioned MyJaxbBean that will result in <code class="code">{"king":"Agamemnon"}</code> JSON output.
</p><div class="example"><a name="d0e2023"></a><p class="title"><b>Example&nbsp;5.4.&nbsp;Tweaking JSON format using JAXB</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 @XmlRootElement
&nbsp;&nbsp;2 <span class="ReservedWord">public</span> <span class="ReservedWord">class</span> MyJaxbBean {
&nbsp;&nbsp;3   
&nbsp;&nbsp;4     @XmlElement(name=<span class="String">"king"</span>)
&nbsp;&nbsp;5     <span class="ReservedWord">public</span> String name;
&nbsp;&nbsp;6   
&nbsp;&nbsp;7     @XmlTransient
&nbsp;&nbsp;8     <span class="ReservedWord">public</span> <span class="ReservedWord">int</span> age;
&nbsp;&nbsp;9  
&nbsp;10     <span class="Comment">// several lines removed       </span>
&nbsp;11 }</pre></div></div><p><br class="example-break">
	</p><p>
	To achieve more important JSON format changes, you will need to configure Jersey JSON procesor itself.
	Various configuration options could be set on  an
	<a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://jersey.dev.java.net/nonav/apidocs/1.4/jersey/com/sun/jersey/api/json/JSONConfiguration.html" target="_top">JSONConfiguration</a>
	instance. The instance could be then further used to create a JSONConfigurated 
	<a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://jersey.dev.java.net/nonav/apidocs/1.4/jersey/com/sun/jersey/api/json/JSONJAXBContext.html" target="_top">JSONJAXBContext</a>,
	which serves as a main configuration point in this area.
	To pass your specialized JSONJAXBContext to Jersey, you will finally need to implement 
	a JAXBContext <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://jsr311.dev.java.net/nonav/releases/1.1/javax/ws/rs/ext/ContextResolver.html" target="_top">ContextResolver</a>
	</p><div class="example"><a name="json.jaxb.context.resolver.example"></a><p class="title"><b>Example&nbsp;5.5.&nbsp;An example of a JAXBContext resolver implementation</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 @Provider
&nbsp;&nbsp;2 <span class="ReservedWord">public</span> <span class="ReservedWord">class</span> JAXBContextResolver <span class="ReservedWord">implements</span> ContextResolver&lt;JAXBContext&gt; {
&nbsp;&nbsp;3 
&nbsp;&nbsp;4     <span class="ReservedWord">private</span> JAXBContext context;
&nbsp;&nbsp;5     <span class="ReservedWord">private</span> Class[] types = {MyJaxbBean.<span class="ReservedWord">class</span>};
&nbsp;&nbsp;6 
&nbsp;&nbsp;7     <span class="ReservedWord">public</span> JAXBContextResolver() <span class="ReservedWord">throws</span> Exception {
&nbsp;&nbsp;8         <span class="ReservedWord">this</span>.context = 
&nbsp;&nbsp;9 	  <span class="ReservedWord">new</span> JSONJAXBContext( 
&nbsp;10 	    JSONConfiguration.natural().build(), types); 
&nbsp;11     }
&nbsp;12 
&nbsp;13     <span class="ReservedWord">public</span> JAXBContext getContext(Class&lt;?&gt; objectType) {
&nbsp;14         <span class="ReservedWord">for</span> (Class type : types) {
&nbsp;15             <span class="ReservedWord">if</span> (type == objectType) {
&nbsp;16                 <span class="ReservedWord">return</span> context;
&nbsp;17             }
&nbsp;18         }
&nbsp;19         <span class="ReservedWord">return</span> null;
&nbsp;20     }
&nbsp;21 }</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><a href="#json.ctx.resolver.init"><img src="images/callouts/1.png" alt="1" border="0"></a> </td><td valign="top" align="left"><p>Creation of our specialized JAXBContext</p></td></tr><tr><td width="5%" valign="top" align="left"><a href="#json.ctx.resolver.config"><img src="images/callouts/2.png" alt="2" border="0"></a> </td><td valign="top" align="left"><p>Final JSON format is given by this JSONConfiguration instance</p></td></tr></table></div></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2056"></a>5.2.2.&nbsp;JSON Notations</h3></div></div></div><p>
      JSONConfiguration allows you to use four various JSON notations. Each of these notations serializes JSON in a different way.
      Following is a list of supported notations:

      </p><div class="itemizedlist"><ul type="disc"><li><p>MAPPED (default notation)</p></li><li><p>NATURAL</p></li><li><p>JETTISON_MAPPED</p></li><li><p>BADGERFISH</p></li></ul></div><p>
      </p><p>
      Individual notations and their further configuration options are described bellow. Rather then explaining rules for mapping
      XML constructs into JSON, the notations will be described using a simple example. Following are JAXB beans, which will be used.
      
      </p><div class="example"><a name="d0e2077"></a><p class="title"><b>Example&nbsp;5.6.&nbsp;JAXB beans for JSON supported notations description, simple address bean</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 @XmlRootElement
&nbsp;&nbsp;2 <span class="ReservedWord">public</span> <span class="ReservedWord">class</span> Address {
&nbsp;&nbsp;3     <span class="ReservedWord">public</span> String street;
&nbsp;&nbsp;4     <span class="ReservedWord">public</span> String town;
&nbsp;&nbsp;5 
&nbsp;&nbsp;6     <span class="ReservedWord">public</span> Address(){}
&nbsp;&nbsp;7 
&nbsp;&nbsp;8     <span class="ReservedWord">public</span> Address(String street, String town) {
&nbsp;&nbsp;9         <span class="ReservedWord">this</span>.street = street;
&nbsp;10         <span class="ReservedWord">this</span>.town = town;
&nbsp;11     }
&nbsp;12 }</pre></div></div><p><br class="example-break">

      </p><div class="example"><a name="d0e2083"></a><p class="title"><b>Example&nbsp;5.7.&nbsp;JAXB beans for JSON supported notations description, contact bean</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 @XmlRootElement
&nbsp;&nbsp;2 <span class="ReservedWord">public</span> <span class="ReservedWord">class</span> Contact {
&nbsp;&nbsp;3 
&nbsp;&nbsp;4     <span class="ReservedWord">public</span> <span class="ReservedWord">int</span> id;
&nbsp;&nbsp;5     <span class="ReservedWord">public</span> String name;
&nbsp;&nbsp;6     <span class="ReservedWord">public</span> List&lt;Address&gt; addresses;
&nbsp;&nbsp;7 
&nbsp;&nbsp;8     <span class="ReservedWord">public</span> Contact() {};
&nbsp;&nbsp;9 
&nbsp;10     <span class="ReservedWord">public</span> Contact(<span class="ReservedWord">int</span> id, String name, List&lt;Address&gt; addresses) {
&nbsp;11         <span class="ReservedWord">this</span>.name = name;
&nbsp;12         <span class="ReservedWord">this</span>.id = id;
&nbsp;13         <span class="ReservedWord">this</span>.addresses = 
&nbsp;14 	        (addresses != null) ? <span class="ReservedWord">new</span> LinkedList&lt;Address&gt;(addresses) : null;
&nbsp;15     }
&nbsp;16 }</pre></div></div><p><br class="example-break">
      </p><p>
      Following text will be mainly working with a contact bean initialized with:
      </p><div class="example"><a name="json.jaxb.bean.init.example"></a><p class="title"><b>Example&nbsp;5.8.&nbsp;JAXB beans for JSON supported notations description, initialization</b></p><div class="example-contents"><pre class="programlisting"><span class="ReservedWord">final</span> Address[] addresses = {<span class="ReservedWord">new</span> Address(<span class="String">"Long Street 1"</span>, <span class="String">"Short Village"</span>)};
Contact contact = <span class="ReservedWord">new</span> Contact(2, <span class="String">"Bob"</span>, Arrays.asList(addresses));</pre></div></div><p><br class="example-break">
I.e. contact bean with <code class="code">id=2</code>, <code class="code">name="Bob"</code> containing 
a single address (<code class="code">street="Long Street 1"</code>, <code class="code">town="Short Village"</code>).
      </p><p>All bellow described configuration options are documented 
      also in apidocs at <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://jersey.dev.java.net/nonav/apidocs/1.4/jersey/com/sun/jersey/api/json/JSONConfiguration.html" target="_top">https://jersey.dev.java.net/nonav/apidocs/1.4/jersey/com/sun/jersey/api/json/JSONConfiguration.html</a>
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2113"></a>5.2.2.1.&nbsp;Mapped notation</h4></div></div></div><p>
       <code class="code">JSONConfiguration</code> based on <code class="literal">mapped</code> notation could be build with 
       </p><pre class="programlisting">JSONConfiguration.mapped().build()</pre><p>
       for usage in a <code class="code">JAXBContext</code> resolver, <a href="json.html#json.jaxb.context.resolver.example" title="Example&nbsp;5.5.&nbsp;An example of a JAXBContext resolver implementation">Example&nbsp;5.5, &#8220;An example of a JAXBContext resolver implementation&#8221;</a>.
       Then a contact bean initialized with <a href="json.html#json.jaxb.bean.init.example" title="Example&nbsp;5.8.&nbsp;JAXB beans for JSON supported notations description, initialization">Example&nbsp;5.8, &#8220;JAXB beans for JSON supported notations description, initialization&#8221;</a>, will be serialized as
       </p><div class="example"><a name="d0e2134"></a><p class="title"><b>Example&nbsp;5.9.&nbsp;JSON expression produced using <code class="literal">mapped</code> notation</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 { "id":"2" 
&nbsp;&nbsp;2  ,"name":"Bob"
&nbsp;&nbsp;3  ,"addresses":{"street":"Long Street 1"
&nbsp;&nbsp;4                     ,"town":"Short Village"}}</pre></div></div><p><br class="example-break">
       The JSON representation seems fine, and will be working flawlessly with Java based Jersey client API.
       </p><p>
       However, at least one issue might appear once you start using it with a JavaScript based client.
       The information, that <code class="code">addresses</code> item represents an array, is being lost for every single element array. 
       If you added another address bean to the contact,</p><pre class="programlisting">contact.addresses.add(<span class="ReservedWord">new</span> Address(<span class="String">"Short Street 1000"</span>, <span class="String">"Long Village"</span>));</pre><p>,
       you would get 
       </p><pre class="programlisting">&nbsp;&nbsp;1 { "id":"2" 
&nbsp;&nbsp;2  ,"name":"Bob"
&nbsp;&nbsp;3  ,"addresses":[{"street":"Long Street 1","town":"Short Village"}
&nbsp;&nbsp;4               ,{"street":"Short Street 1000","town":"Long Village"}]}</pre><p>
        Both representations are correct, but you will not be able to consume them using a single JavaScript client,
	because to access <code class="code">"Short Village"</code> value, you will write <code class="code">addresses.town</code> in one
	case and <code class="code">addresses[0].town</code> in the other.
	To fix this issue, you need to instruct the JSON processor, what items need to be treated as arrays
	by setting an optional property, <code class="literal">arrays</code>, on your <code class="code">JSONConfiguration</code> object.
	For our case, you would do it with
       </p><div class="example"><a name="d0e2169"></a><p class="title"><b>Example&nbsp;5.10.&nbsp;Force arrays in <code class="literal">mapped</code> JSON notation</b></p><div class="example-contents"><pre class="programlisting">JSONConfiguration.mapped().arrays(<span class="String">"addresses"</span>).build()</pre></div></div><p><br class="example-break">
       You can use multiple string values in the <code class="literal">arrays</code> method call, in case you are dealing with more
       than one array item in your beans. Similar mechanism (one or more argument values) applies also for all below desribed options.
       </p><p>Another issue might be, that number value, <code class="literal">2</code>, for <code class="code">id</code> item 
       gets written as a string, <code class="literal">"2"</code>. To avoid this, you can use another optional property on <code class="code">JSONConfiguration</code>
       called <code class="literal">nonStrings</code>.
       </p><div class="example"><a name="d0e2198"></a><p class="title"><b>Example&nbsp;5.11.&nbsp;Force non-string values in <code class="literal">mapped</code> JSON notation</b></p><div class="example-contents"><pre class="programlisting">JSONConfiguration.mapped().arrays(<span class="String">"addresses"</span>).nonStrings(<span class="String">"id"</span>).build()</pre></div></div><p><br class="example-break">
	</p><p>
       It might happen you use XML attributes in your JAXB beans. In <code class="literal">mapped</code> JSON notation, these attribute names are prefixed with <code class="literal">@</code>
       character. If <code class="code">id</code> was an attribute, it&acute;s definition would look like:
       </p><pre class="programlisting">  ...
  @XmlAttribute
  <span class="ReservedWord">public</span> <span class="ReservedWord">int</span> id;
  ...</pre><p>
       and then you would get </p><pre class="programlisting">{"@id":"2" ...</pre><p> at the JSON output.
       In case, you want to get rid of the <code class="literal">@</code> prefix, you can take advantage of another configuration 
       option of <code class="literal">JSONConfiguration</code>, called <code class="literal">attributeAsElement</code>.
       Usage is similar to previous options.
       </p><div class="example"><a name="d0e2233"></a><p class="title"><b>Example&nbsp;5.12.&nbsp;XML attributes as XML elements in <code class="literal">mapped</code> JSON notation</b></p><div class="example-contents"><pre class="programlisting">JSONConfiguration.mapped().attributeAsElement(<span class="String">"id"</span>).build()</pre></div></div><p><br class="example-break">
       </p><p>
	<code class="literal">Mapped</code> JSON notation was designed to produce the simplest possible JSON expression out of JAXB beans. While in XML,
	you must always have a root tag to start a XML document with, there is no such a constraint in JSON. If you wanted to be strict,
	you might have wanted to keep a XML root tag equivalent generated in your JSON. If that is the case, another configuration option
	is available for you, which is called <code class="literal">rootUnwrapping</code>. You can use it as follows:
       </p><div class="example"><a name="json.jaxb.mapped.root.unwrapping"></a><p class="title"><b>Example&nbsp;5.13.&nbsp;Keep XML root tag equivalent in JSON <code class="literal">mapped</code> JSON notation</b></p><div class="example-contents"><pre class="programlisting">JSONConfiguration.mapped().rootUnwrapping(false).build()</pre></div></div><p><br class="example-break">
       and get the following JSON for our <code class="literal">Contact</code> bean:
       </p><div class="example"><a name="d0e2262"></a><p class="title"><b>Example&nbsp;5.14.&nbsp;XML root tag equivalent kept in JSON using <code class="literal">mapped</code> notation</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 {"contact":{ "id":"2" 
&nbsp;&nbsp;2  ,"name":"Bob"
&nbsp;&nbsp;3  ,"addresses":{"street":"Long Street 1"
&nbsp;&nbsp;4                     ,"town":"Short Village"}}}</pre></div></div><p><br class="example-break">
	<code class="literal">rootUnwrapping</code> option is set to <code class="literal">true</code> by default. You should switch it to <code class="literal">false</code>
	if you use inheritance at your JAXB beans. Then JAXB might try to encode type information into root element names, and by stripping these
	elements off, you could break unmarshalling.
	</p><p>
	In version 1.1.1-ea, XML namespace support was added to the MAPPED JSON notation. There is of course no such thing as XML namespaces in JSON,
	but when working from JAXB, XML infoset is used as an intermediary format. And then when various XML namespaces are used, ceratin information 
	related to the concrete namespaces is needed even in JSON data, so that the JSON procesor could correctly unmarshal JSON to XML and JAXB. 
	To make it short, the XML namespace support means, you should be able to use the very same JAXB beans for XML and JSON even if XML namespaces are involved.
	</p><p>
	Namespace mapping definition is similar to <a href="json.html#json.jaxb.jettison.mapped.ns.def" title="Example&nbsp;5.19.&nbsp;XML namespace to JSON mapping configuration for Jettison based mapped notation">Example&nbsp;5.19, &#8220;XML namespace to JSON mapping configuration for Jettison based <code class="literal">mapped</code> notation&#8221;</a> 
      </p><div class="example"><a name="d0e2286"></a><p class="title"><b>Example&nbsp;5.15.&nbsp;XML namespace to JSON mapping configuration for <code class="literal">mapped</code> notation</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1         Map&lt;String,String&gt; ns2json = <span class="ReservedWord">new</span> HashMap&lt;String, String&gt;();
&nbsp;&nbsp;2         ns2json.put(<span class="String">"http://example.com"</span>, <span class="String">"example"</span>);
&nbsp;&nbsp;3         context = <span class="ReservedWord">new</span> JSONJAXBContext(
&nbsp;&nbsp;4 	      JSONConfiguration.mapped()
&nbsp;&nbsp;5 	           .xml2JsonNs(ns2json).build(), types);</pre></div></div><p><br class="example-break">
	</p><p>
	Dot character (.) will be used by default as a namespace separator in the JSON identifiers. E.g. for the above mentioned <code class="literal">example</code> namespace
	and tag <code class="literal">T</code>, <code class="literal">"example.T"</code> JSON identifier will be generated. To change this default behaviour, you can use the <code class="literal">nsSeparator</code>
	method on the mapped JSONConfiguration builder: <code class="literal">JSONConfiguration.mapped().xml2JsonNs(ns2json).nsSeparator(':').build()</code>. Then you will 
	get <code class="literal">"example:T"</code> instead of <code class="literal">"example.T"</code> generated. This option should be used carefully, as the Jersey framework does not even try to check
	conflicts between the user selected separator character and the tag and/or namespace names. 
	</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2318"></a>5.2.2.2.&nbsp;Natural notation</h4></div></div></div><p>
       After using <code class="literal">mapped</code> JSON notation for a while, it was apparent, that a need to configure all the various things
       manually could be a bit problematic. To avoid the manual work, a new, <code class="literal">natural</code>, JSON notation was introduced in Jersey version 1.0.2.
       With <code class="literal">natural</code> notation, Jersey will automatically figure out how individual items need to be processed, so that you 
       do not need to do any kind of manual configuration. Java arrays and lists are mapped into JSON arrays, even for single-element cases. 
       Java numbers and booleans are correctly mapped into JSON numbers and booleans, and you do not need to bother with XML attributes,
       as in JSON, they keep the original names. So  without any additional configuration, just using
       </p><pre class="programlisting">JSONConfiguration.natural().build()</pre><p>
       for configuring your <code class="code">JAXBContext</code>, you will get the following JSON for the bean 
       initialized at <a href="json.html#json.jaxb.bean.init.example" title="Example&nbsp;5.8.&nbsp;JAXB beans for JSON supported notations description, initialization">Example&nbsp;5.8, &#8220;JAXB beans for JSON supported notations description, initialization&#8221;</a>:
       </p><div class="example"><a name="d0e2340"></a><p class="title"><b>Example&nbsp;5.16.&nbsp;JSON expression produced using <code class="literal">natural</code> notation</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 { "id":2
&nbsp;&nbsp;2  ,"name":"Bob"
&nbsp;&nbsp;3  ,"addresses":[{"street":"Long Street 1"
&nbsp;&nbsp;4                      ,"town":"Short Village"}]}</pre></div></div><p><br class="example-break">
       You might notice, that the single element array <code class="literal">addresses</code> remains an array, and also the non-string <code class="literal">id</code>
       value is not limited with double quotes, as <code class="literal">natural</code> notation automatically detects these things.
       </p><p>
       To support cases, when you use inheritance for your JAXB beans, an option was introduced to the <code class="literal">natural</code> JSON configuration builder
       to forbid XML root element stripping. The option looks pretty same as at the default <code class="literal">mapped</code> notation case (<a href="json.html#json.jaxb.mapped.root.unwrapping" title="Example&nbsp;5.13.&nbsp;Keep XML root tag equivalent in JSON mapped JSON notation">Example&nbsp;5.13, &#8220;Keep XML root tag equivalent in JSON <code class="literal">mapped</code> JSON notation&#8221;</a>).
       </p><div class="example"><a name="json.jaxb.natural.root.unwrapping"></a><p class="title"><b>Example&nbsp;5.17.&nbsp;Keep XML root tag equivalent in JSON <code class="literal">natural</code> JSON notation</b></p><div class="example-contents"><pre class="programlisting">JSONConfiguration.natural().rootUnwrapping(false).build()</pre></div></div><p><br class="example-break">
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2377"></a>5.2.2.3.&nbsp;Jettison mapped notation</h4></div></div></div><p>
       Next two notations are based on project <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jettison.codehaus.org/User%27s+Guide" target="_top">Jettison</a>.
       You might want to use one of these notations, when working with more complex XML documents. Namely when you deal with 
       multiple XML namespaces in your JAXB beans. 
       </p><p>
       Jettison based <code class="literal">mapped</code> notation could be configured using:
       </p><pre class="programlisting">JSONConfiguration.mappedJettison().build()</pre><p>
       If nothing else is configured, you will get similar JSON output as for the default, <code class="literal">mapped</code>, notation:
       </p><div class="example"><a name="d0e2396"></a><p class="title"><b>Example&nbsp;5.18.&nbsp;JSON expression produced using Jettison based <code class="literal">mapped</code> notation</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 { "contact:{"id":2
&nbsp;&nbsp;2               ,"name":"Bob"
&nbsp;&nbsp;3               ,"addresses":{"street":"Long Street 1"
&nbsp;&nbsp;4                                  ,"town":"Short Village"}}</pre></div></div><p><br class="example-break">
	The only difference is, your numbers and booleans will not be converted into strings, but you have no option for forcing arrays remain arrays
	in single-element case. Also the JSON object, representing XML root tag is being produced.
       </p><p>
       If you need to deal with various XML namespaces, however, you will find Jettison <code class="literal">mapped</code> notation pretty useful.
       Lets define a particular namespace for <code class="code">id</code> item:
       </p><pre class="programlisting">  ...
  @XmlElement(namespace=<span class="String">"http://example.com"</span>)
  <span class="ReservedWord">public</span> <span class="ReservedWord">int</span> id;
  ...</pre><p>
 	Then you simply confgure a mapping from XML namespace into JSON prefix as follows:
      </p><div class="example"><a name="json.jaxb.jettison.mapped.ns.def"></a><p class="title"><b>Example&nbsp;5.19.&nbsp;XML namespace to JSON mapping configuration for Jettison based <code class="literal">mapped</code> notation</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1         Map&lt;String,String&gt; ns2json = <span class="ReservedWord">new</span> HashMap&lt;String, String&gt;();
&nbsp;&nbsp;2         ns2json.put(<span class="String">"http://example.com"</span>, <span class="String">"example"</span>);
&nbsp;&nbsp;3         context = <span class="ReservedWord">new</span> JSONJAXBContext(
&nbsp;&nbsp;4 	      JSONConfiguration.mappedJettison()
&nbsp;&nbsp;5 	           .xml2JsonNs(ns2json).build(), types);</pre></div></div><p><br class="example-break">
       Resulting JSON will look like in the example bellow.
        </p><div class="example"><a name="d0e2425"></a><p class="title"><b>Example&nbsp;5.20.&nbsp;JSON expression with XML namespaces mapped into JSON</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 { "contact:{"example.id":2
&nbsp;&nbsp;2               ,"name":"Bob"
&nbsp;&nbsp;3               ,"addresses":{"street":"Long Street 1"
&nbsp;&nbsp;4                                  ,"town":"Short Village"}}</pre></div></div><p><br class="example-break">
       Please note, that <code class="code">id</code> item became <code class="code">example.id</code> based on the XML namespace mapping.
       If you have more XML namespaces in your XML, you will need to configure appropriate mapping for all of them
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2437"></a>5.2.2.4.&nbsp;Badgerfish notation</h4></div></div></div><p>
       Badgerfish notation is the other notation based on Jettison. From JSON and JavaScript perspective, this notation is definitely
       the worst readable one. You will probably not want to use it, unless you need to make sure your JAXB beans could be flawlessly
       written and read back to and from JSON, without bothering with any formatting configuration, namespaces, etc.
       </p><p>
       <code class="code">JSONConfiguration</code> instance using <code class="literal">badgerfish</code> notation could be built with
       </p><pre class="programlisting">JSONConfiguration.badgerFish().build()</pre><p>
       and the output JSON for <a href="json.html#json.jaxb.bean.init.example" title="Example&nbsp;5.8.&nbsp;JAXB beans for JSON supported notations description, initialization">Example&nbsp;5.8, &#8220;JAXB beans for JSON supported notations description, initialization&#8221;</a> will be as follows.
       </p><div class="example"><a name="d0e2455"></a><p class="title"><b>Example&nbsp;5.21.&nbsp;JSON expression produced using <code class="literal">badgerfish</code> notation</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 {"contact":{"id":{"$":"2"}
&nbsp;&nbsp;2               ,"name":{"$":"Bob"}
&nbsp;&nbsp;3               ,"addresses":{"street":{"$":"Long Street 1"}
&nbsp;&nbsp;4                                  ,"town":{"$":"Short Village"}}}}</pre></div></div><p><br class="example-break">
       </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2464"></a>5.2.3.&nbsp;Examples</h3></div></div></div><p>Download <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://download.java.net/maven/2/com/sun/jersey/samples/json-from-jaxb/1.4/json-from-jaxb-1.4-project.zip" target="_top">http://download.java.net/maven/2/com/sun/jersey/samples/json-from-jaxb/1.4/json-from-jaxb-1.4-project.zip</a>
   or
   <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://download.java.net/maven/2/com/sun/jersey/samples/jmaki-backend/1.4/jmaki-backend-1.4-project.zip" target="_top">http://download.java.net/maven/2/com/sun/jersey/samples/jmaki-backend/1.4/jmaki-backend-1.4-project.zip</a>
   to get a more complex example using JAXB based JSON support.
   </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2475"></a>5.3.&nbsp;Low-Level JSON support</h2></div></div></div><p>Using this approach means you will be using JSONObject and/or JSONArray classes for your data representations.
    These classes are actually taken from Jettison project, but conform to the description 
    provided at <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.json.org/java/index.html" target="_top"> http://www.json.org/java/index.html</a>.
    </p><p>
    The biggest advantage here is, that you will gain full control over the JSON format produced and consumed.
    On the other hand, dealing with your data model objects will probably be a bit more complex, than when taking the JAXB based approach.
    Differencies are depicted at the following code snipets.
    </p><p>
    </p><div class="example"><a name="d0e2487"></a><p class="title"><b>Example&nbsp;5.22.&nbsp;JAXB bean creation</b></p><div class="example-contents"><pre class="programlisting">MyJaxbBean myBean = <span class="ReservedWord">new</span> MyJaxbBean(<span class="String">"Agamemnon"</span>, 32);</pre></div></div><p><br class="example-break">
    
    Above you construct a simple JAXB bean, which could be written in JSON as <code class="code">{"name":"Agamemnon", "age":32}</code>
    </p><p>
    Now to build an equivalent JSONObject (in terms of resulting JSON expression), you would need several more lines of code.
    
    </p><div class="example"><a name="d0e2498"></a><p class="title"><b>Example&nbsp;5.23.&nbsp;Constructing a JSONObject</b></p><div class="example-contents"><pre class="programlisting">&nbsp;&nbsp;1 JSONObject myObject = <span class="ReservedWord">new</span> JSONObject();
&nbsp;&nbsp;2 myObject.JSONObject myObject = <span class="ReservedWord">new</span> JSONObject();
&nbsp;&nbsp;3 <span class="ReservedWord">try</span> {
&nbsp;&nbsp;4   myObject.put(<span class="String">"name"</span>, <span class="String">"Agamemnon"</span>);
&nbsp;&nbsp;5   myObject.put(<span class="String">"age"</span>, 32);
&nbsp;&nbsp;6 } <span class="ReservedWord">catch</span> (JSONException ex) {
&nbsp;&nbsp;7   LOGGER.log(Level.SEVERE, <span class="String">"Error ..."</span>, ex);
&nbsp;&nbsp;8 }</pre></div></div><p><br class="example-break">
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2504"></a>5.3.1.&nbsp;Examples</h3></div></div></div><p>Download <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://download.java.net/maven/2/com/sun/jersey/samples/bookmark/1.4/bookmark-1.4-project.zip" target="_top">http://download.java.net/maven/2/com/sun/jersey/samples/bookmark/1.4/bookmark-1.4-project.zip</a> 
   to get a more complex example using low-level JSON support.
   </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xml.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="linking.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;4.&nbsp;XML Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;6.&nbsp;Declarative Hyperlinking</td></tr></table></div></body></html>