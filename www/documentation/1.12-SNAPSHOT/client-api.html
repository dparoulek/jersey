<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;Client API</title><link rel="stylesheet" href="http://jersey.java.net/documentation.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="Jersey 1.12-SNAPSHOT User Guide"><link rel="up" href="index.html" title="Jersey 1.12-SNAPSHOT User Guide"><link rel="prev" href="jax-rs.html" title="Chapter&nbsp;2.&nbsp;Overview of JAX-RS 1.1"><link rel="next" href="xml.html" title="Chapter&nbsp;4.&nbsp;XML Support"><script xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3160303-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;3.&nbsp;Client API</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="jax-rs.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="xml.html">Next</a></td></tr></table><hr></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" style="float:right"><a href="http://jersey.java.net"><img src="http://jersey.java.net/images/Jersey_yellow.png"></a></div><small xmlns:fo="http://www.w3.org/1999/XSL/Format">Links: <a href="index.html">Table of Contents</a> | <a href="user-guide.html">Single HTML</a></small><div class="chapter" title="Chapter&nbsp;3.&nbsp;Client API"><div class="titlepage"><div><div><h2 class="title"><a name="client-api"></a>Chapter&nbsp;3.&nbsp;Client API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="client-api.html#d4e534">3.1. Introduction</a></span></dt><dt><span class="section"><a href="client-api.html#d4e548">3.2. Uniform Interface Constraint</a></span></dt><dt><span class="section"><a href="client-api.html#d4e573">3.3. Ease of use and reusing JAX-RS artifacts</a></span></dt><dt><span class="section"><a href="client-api.html#d4e609">3.4. Getting started with the Jersey client</a></span></dt><dt><span class="section"><a href="client-api.html#d4e618">3.5. Overview of the API</a></span></dt><dd><dl><dt><span class="section"><a href="client-api.html#d4e623">3.5.1. Configuring a Client and WebResource</a></span></dt><dt><span class="section"><a href="client-api.html#d4e644">3.5.2. Building a request</a></span></dt><dt><span class="section"><a href="client-api.html#d4e665">3.5.3. Receiving a response</a></span></dt><dt><span class="section"><a href="client-api.html#d4e677">3.5.4. Creating new WebResources from a WebResource</a></span></dt><dt><span class="section"><a href="client-api.html#d4e683">3.5.5. Java instances and types for representations</a></span></dt></dl></dd><dt><span class="section"><a href="client-api.html#d4e694">3.6. Adding support for new representations</a></span></dt><dt><span class="section"><a href="client-api.html#d4e706">3.7. Using filters</a></span></dt><dd><dl><dt><span class="section"><a href="client-api.html#d4e740">3.7.1. Supported filters</a></span></dt></dl></dd><dt><span class="section"><a href="client-api.html#d4e759">3.8. Testing services</a></span></dt><dt><span class="section"><a href="client-api.html#d4e778">3.9. Security with Http(s)URLConnection</a></span></dt><dd><dl><dt><span class="section"><a href="client-api.html#d4e780">3.9.1. With Http(s)URLConnection</a></span></dt><dt><span class="section"><a href="client-api.html#d4e796">3.9.2. With Apache HTTP client</a></span></dt></dl></dd></dl></div>
    
    <div class="section" title="3.1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e534"></a>3.1.&nbsp;Introduction</h2></div></div></div>
        
        <p>This section introduces the client API and some features such as filters and how to use them with
        security features in the JDK. The Jersey client API is a high-level Java based API for interoperating
        with RESTful Web services.
        It makes it very easy to interoperate with RESTful Web services and
        enables a developer to concisely and efficiently implement a reusable client-side solution that
        leverages existing and well established client-side HTTP implementations.
        </p>
        <p>The Jersey client API can be utilized to interoperate with any RESTful Web service, implemented
        using one of many frameworks, and is not restricted to services implemented using JAX-RS.
        However, developers familiar with JAX-RS should find the Jersey client API complementary to their services,
        especially if the client API is utilized by those services themselves, or to test those services.
        </p>
        <p>The goals of the Jersey client API are threefold:</p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>Encapsulate a key constraint of the REST architectural style, namely the Uniform Interface
                Constraint and associated data elements, as client-side Java artifacts;
                </p>
            </li><li class="listitem">
                <p>Make it as easy to interoperate with RESTful Web services as JAX-RS makes it easy to build
                RESTful Web services; and
                </p>
            </li><li class="listitem">
                <p>Leverage artifacts of the JAX-RS API for the client side. Note that JAX-RS is currently a
                server-side only API.
                </p>
            </li></ol></div>
        <p>The Jersey Client API supports a pluggable architecture to enable the use of different underlying HTTP client
        implementations. Two such implementations are supported and leveraged: the 
        <code class="literal">Http(s)URLConnection</code> classes
        supplied with the JDK; and the Apache HTTP client.
        </p>
    </div>

    <div class="section" title="3.2.&nbsp;Uniform Interface Constraint"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e548"></a>3.2.&nbsp;Uniform Interface Constraint</h2></div></div></div>
        
        <p>The uniform interface constraint bounds the architecture of RESTful Web services so that a client, such
        as a browser, can utilize the same interface to communicate with any service. This is a very powerful concept
        in software engineering that makes Web-based search engines and service mash-ups possible. It induces properties
        such as:
        </p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>simplicity, the architecture is easier to understand and maintain; and</p>
            </li><li class="listitem">
                <p>modifiability or loose coupling, clients and services can evolve over time perhaps in new and
                unexpected ways, while retaining backwards compatibility.
                </p>
            </li></ol></div>
        <p>Further constraints are required:</p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>every resource is identified by a URI;</p>
            </li><li class="listitem">
                <p>a client interacts with the resource via HTTP requests and responses using a fixed set of
                HTTP methods;
                </p>
            </li><li class="listitem">
                <p>one or more representations can be retured and are identified by media types; and</p>
            </li><li class="listitem">
                <p>the contents of which can link to further resources.</p>
            </li></ol></div>
        <p>The above process repeated over and again should be familiar to anyone who has used a browser to fill
        in HTML forms and follow links. That same process is applicable to non-browser based clients.
        </p>
        <p>Many existing Java-based client APIs, such as the Apache HTTP client API or
            <code class="literal">java.net.HttpURLConnection</code>
        supplied with the JDK place too much focus on the Client-Server constraint for the exchanges of request and
        responses rather than a resource, identified by a URI, and the use of a fixed set of HTTP methods.
        </p>
        <p>A resource in the Jersey client API is an instance of the Java class
            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/WebResource.html" target="_top">WebResource</a>,
            and encapsulates a URI. The fixed set of HTTP methods are methods on
            <code class="literal">WebResource</code>
            or if using the builder
            pattern (more on this later) are the last methods to be called when invoking an HTTP method on a resource.
            The representations are Java types, instances of which, may contain links that new instances of 
            <code class="literal">WebResource</code> may be created from.
        </p>
    </div>

    <div class="section" title="3.3.&nbsp;Ease of use and reusing JAX-RS artifacts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e573"></a>3.3.&nbsp;Ease of use and reusing JAX-RS artifacts</h2></div></div></div>
        
        <p>Since a resource is represented as a Java type it makes it easy to configure, pass around and inject in
        ways that is not so intuitive or possible with other client-side APIs.
        </p>
        <p>The Jersey Client API reuses many aspects of the JAX-RS and the Jersey implementation such as:</p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>URI building using
                    <a class="ulink" href="http://jsr311.java.net/nonav/releases/1.1/javax/ws/rs/core/UriBuilder.html" target="_top">UriBuilder</a> and
                    <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/uri/UriTemplate.html" target="_top">UriTemplate</a>
                    to safely build URIs;
                </p>
            </li><li class="listitem">
                <p>Support for Java types of representations such as
                    <code class="literal">byte[]</code>,
                    <code class="literal">String</code>,
                    <code class="literal">InputStream</code>,
                    <code class="literal">File</code>,
                    <code class="literal">DataSource</code>
                and JAXB beans in addition to Jersey specific features such as
                    <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/json/package-summary.html" target="_top">JSON</a> support and
                    <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/contribs/jersey-multipart/index.html" target="_top">MIME Multipart</a> support.
                </p>
            </li><li class="listitem">
                <p>Using the builder pattern to make it easier to construct requests.</p>
            </li></ol></div>
        <p>Some APIs, like the Apache HTTP client or
            <a class="ulink" href="http://docs.oracle.com/javase/1.5.0/docs/api/java/net/HttpURLConnection.html" target="_top">java.net.HttpURLConnection</a>,
            can be rather hard to use and/or require too much code to do something relatively simple.
        </p>
        <p>This is why the Jersey Client API provides support for wrapping HttpURLConnection and the Apache
        HTTP client. Thus it is possible to get the benefits of the established implementations and features
        while getting the ease of use benefit.
        </p>
        <p>It is not intuitive to send a POST request with form parameters and receive a response as a
        JAXB object with such an API. For example with the Jersey API this is very easy:
        </p><div class="example"><a name="d4e597"></a><p class="title"><b>Example&nbsp;3.1.&nbsp;POST request with form parameters</b></p><div class="example-contents">
            
            <pre class="programlisting">&nbsp;&nbsp;1 Form f = new Form();
&nbsp;&nbsp;2 f.add("x", "foo");
&nbsp;&nbsp;3 f.add("y", "bar");
&nbsp;&nbsp;4 
&nbsp;&nbsp;5 Client c = Client.create();
&nbsp;&nbsp;6 WebResource r = c.resource("http://localhost:8080/form");
&nbsp;&nbsp;7 
&nbsp;&nbsp;8 JAXBBean bean = r.
&nbsp;&nbsp;9     type(MediaType.APPLICATION_FORM_URLENCODED_TYPE)
&nbsp;10     .accept(MediaType.APPLICATION_JSON_TYPE)
&nbsp;11     .post(JAXBBean.class, f);</pre>
        </div></div><p><br class="example-break">
        In the above code a
            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/representation/Form.html" target="_top">Form</a> is created with two parameters, a new
            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/WebResource.html" target="_top">WebResource</a> instance is created from a
            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/Client.html" target="_top">Client</a> then the
            <code class="literal">Form</code> instance is <code class="literal">POST</code>ed to
            the resource, identified with the form media type, and the response is requested as an instance of a JAXB bean
            with an acceptable media type identifying the Java Script Object
            Notation (JSON) format. The Jersey client API manages the serialization of the <code class="literal">Form</code> instance to produce the
            request and de-serialization of the response to consume as an instance of a JAXB bean.
        </p>
        <p>If the code above was written using
            <code class="literal">HttpURLConnection</code> then the developer would have to write code to serialize the
        form sent in the POST request and de-serialize the response to the JAXB bean. In addition further code would have to be written
        to make it easy to reuse the same resource &#8220;http://localhost:8080/form&#8221; that is encapsulated in the 
            <code class="literal">WebResource</code> type.
        </p>
    </div>

    <div class="section" title="3.4.&nbsp;Getting started with the Jersey client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e609"></a>3.4.&nbsp;Getting started with the Jersey client</h2></div></div></div>
        
        <p>Refer to the
         <a class="ulink" href="http://jersey.java.net/nonav/documentation/1.12-SNAPSHOT/chapter_deps.html#chapter_deps" target="_top">dependencies chapter</a>,
            and specifically the <a class="ulink" href="http://jersey.java.net/nonav/documentation/1.12-SNAPSHOT/chapter_deps.html#core_client" target="_top">Core client</a> section,
            for details on the dependencies when using the Jersey client with Maven and Ant.
        </p>
        <p>Refer to the
            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/package-summary.html" target="_top">Java API documentation</a> for details on the Jersey client API packages and classes.
        </p>
        <p>Refer to the
            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/contribs/jersey-apache-client/index.html" target="_top">Java API Apache HTTP client documentation</a> for details on how to use the Jersey client API with the Apache HTTP client.
        </p>
    </div>

    <div class="section" title="3.5.&nbsp;Overview of the API"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e618"></a>3.5.&nbsp;Overview of the API</h2></div></div></div>
        
        <p>To utilize the client API it is first necessary to create an instance of a
            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/Client.html" target="_top">Client</a>, for example:
            </p><pre class="programlisting">    Client c = Client.create();</pre><p>
        </p>
        <div class="section" title="3.5.1.&nbsp;Configuring a Client and WebResource"><div class="titlepage"><div><div><h3 class="title"><a name="d4e623"></a>3.5.1.&nbsp;Configuring a Client and WebResource</h3></div></div></div>
            
            <p>The client instance can then be configured by setting properties on the map returned from
            the
                <code class="literal">getProperties</code> methods or by calling the specific setter methods,
            for example the following configures the client to perform automatic redirection for
            appropriate responses:
                </p><pre class="programlisting">    c.getProperties().put(
        ClientConfig.PROPERTY_FOLLOW_REDIRECTS, true);</pre><p>
            which is equivalent to the following:
                </p><pre class="programlisting">    c.setFollowRedirects(true);</pre><p>
            Alternatively it is possible to create a <code class="literal">Client</code> instance using a
                <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/config/ClientConfig.html" target="_top">ClientConfig</a>
            object for example:
                </p><pre class="programlisting">    ClientConfig cc = new DefaultClientConfig();
    cc.getProperties().put(
        ClientConfig.PROPERTY_FOLLOW_REDIRECTS, true);
    Client c = Client.create(cc);</pre><p>
            </p>
            <p>Once a client instance is created and configured it is then possible to obtain a
                <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/WebResource.html" target="_top">WebResource</a>
                instance, which will inherit the configuration declared on the client instance.
                For example, the following creates a reference to a Web resource with the URI
                &#8220;http://localhost:8080/xyz&#8221;:
                </p><pre class="programlisting">    WebResource r = c.resource("http://localhost:8080/xyz");</pre><p>
            and redirection will be configured for responses to requests invoked on the Web resource.
            </p>
            <p>
                <code class="literal">Client</code> instances are expensive resources. It is recommended a configured
            instance is reused for the creation of Web resources. The creation of Web resources, the building
            of requests and receiving of responses are guaranteed to be thread safe. Thus a
                <code class="literal">Client</code>
            instance and 
                <code class="literal">WebResource</code> instances may be shared between multiple threads.
            </p>
            <p>In the above cases a
                <code class="literal">WebResource</code> instance will utilize
                <code class="literal">HttpUrlConnection</code> or
                <code class="literal">HttpsUrlConnection</code>,
            if the URI scheme of the
                <code class="literal">WebResource</code> is &#8220;http&#8221; or &#8220;https&#8221; respectively.
            </p>
        </div>
        <div class="section" title="3.5.2.&nbsp;Building a request"><div class="titlepage"><div><div><h3 class="title"><a name="d4e644"></a>3.5.2.&nbsp;Building a request</h3></div></div></div>
            
            <p>Requests to a Web resource are built using the builder pattern (see
                <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/RequestBuilder.html" target="_top">RequestBuilder</a>)
                where the terminating method corresponds to an HTTP method (see
                <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/UniformInterface.html" target="_top">UniformInterface</a>).
                For example,
                </p><pre class="programlisting">    String response = r.accept(
        MediaType.APPLICATION_JSON_TYPE,
        MediaType.APPLICATION_XML_TYPE).
        header("X-FOO", "BAR").
        get(String.class);</pre><p>
            </p>
            <p>The above sends a GET request with an
                <code class="literal">Accept</code> header of
                <code class="literal">application/json</code>,
                <code class="literal">application/xml</code> and a
            non-standard header 
                <code class="literal">X-FOO</code> of
                <code class="literal">BAR</code>.
            </p>
            <p>If the request has a request entity (or representation) then an instance
            of a Java type can be declared in the terminating HTTP method, for
                <code class="literal">PUT</code>,
                <code class="literal">POST</code> and
                <code class="literal">DELETE</code> requests.
            For example, the following sends a POST request:
                </p><pre class="programlisting">    String request = "content";
    String response = r.accept(
        MediaType.APPLICATION_JSON_TYPE,
        MediaType.APPLICATION_XML_TYPE).
        header("X-FOO", "BAR").
        post(String.class, request);</pre><p>
            where the String "content" will be serialized as the request
            entity (see the section "Java instances and types for representations"
            section for further details on the supported Java types). The
            <code class="literal">Content-Type</code> of the request entity may be declared
            using the <code class="literal">type</code> builder method as follows:
            </p><pre class="programlisting">    String response = r.accept(
         MediaType.APPLICATION_JSON_TYPE,
         MediaType.APPLICATION_XML_TYPE).
         header("X-FOO", "BAR").
         type(MediaType.TEXT_PLAIN_TYPE).
         post(String.class, request);</pre><p>
            or alternatively the request entity and type may be declared
            using the entity method as follows:
            </p><pre class="programlisting">    String response = r.accept(
         MediaType.APPLICATION_JSON_TYPE,
         MediaType.APPLICATION_XML_TYPE).
         header("X-FOO", "BAR").
         entity(request, MediaType.TEXT_PLAIN_TYPE).
         post(String.class);</pre><p>
            </p>
            </div>

            <div class="section" title="3.5.3.&nbsp;Receiving a response"><div class="titlepage"><div><div><h3 class="title"><a name="d4e665"></a>3.5.3.&nbsp;Receiving a response</h3></div></div></div>
                
                <p>If the response has a entity (or representation) then the 
                Java type of the instance required is declared in the terminating HTTP method.
                In the above examples a response entity is expected and an instance of <code class="literal">String</code>
                is requested. The response entity will be de-serialized to a String
                instance.</p>
                <p>If response meta-data is required then the Java type
                    <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/ClientResponse.html" target="_top">ClientResponse</a>
                    can be declared from which the response status, headers and entity may be obtained.
                    For example, the following gets both the entity tag and response entity from the
                    response:
                </p><pre class="programlisting">    ClientResponse response = r.get(ClientResponse.class);
    EntityTag e = response.getEntityTag();
    String entity = response.getEntity(String.class);</pre>
                <p>If the <code class="literal">ClientResponse</code> type is not utilized and the response
                status is greater than or equal to 300 then the runtime exception
                 <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/UniformInterfaceException.html" target="_top">UniformInterfaceException</a>
                 is thrown. This exception may be caught and the <code class="literal">ClientResponse</code> obtained as follows:
                </p><pre class="programlisting">    try {
        String entity = r.get(String.class);
    } catch (UniformInterfaceException ue) {
        ClientResponse response = ue.getResponse();
    }</pre>
            </div>

            <div class="section" title="3.5.4.&nbsp;Creating new WebResources from a WebResource"><div class="titlepage"><div><div><h3 class="title"><a name="d4e677"></a>3.5.4.&nbsp;Creating new WebResources from a WebResource</h3></div></div></div>
                
                <p>A new
                    <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/WebResource.html" target="_top">WebResource</a>
                    can be created from an existing <code class="literal">WebResource</code> by building from the latter's URI.
                    Thus it is possible to build the request URI before building the request. For example, the
                    following appends a new path segment and adds some query parameters:
                </p><pre class="programlisting">    WebResource r = c.resource("http://localhost:8080/xyz");

    MultivaluedMap&lt;String, String&gt; params = MultivaluedMapImpl();
    params.add("foo", "x");
    params.add("bar", "y");
    
    String response = r.path("abc").
        queryParams(params).
        get(String.class);</pre><p>
                that results in a GET request to the URI "http://localhost:8080/xyz/abc?foo=x&amp;bar=y".</p>
            </div>
            
            <div class="section" title="3.5.5.&nbsp;Java instances and types for representations"><div class="titlepage"><div><div><h3 class="title"><a name="d4e683"></a>3.5.5.&nbsp;Java instances and types for representations</h3></div></div></div>
                
                <p>All the Java types for representations supported by the Jersey server side for 
                requests and responses are also supported on the client side. This includes the standard
                Java types as specified by JAX-RS in
                    <a class="ulink" href="http://jsr311.java.net/nonav/releases/1.0/spec/index.html" target="_top">section 4.2.4</a>
                    in addition to JSON, Atom and Multipart MIME as supported by Jersey.
                </p>
                <p>To process a response entity (or representation) as a stream of bytes use InputStream as follows:
                </p><pre class="programlisting">    InputStream in = r.get(InputStream.class);
    // Read from the stream
    in.close();</pre><p>
                Note that it is important to close the stream after processing so that resources are freed up.</p>
                <p>To <code class="literal">POST</code> a file use <code class="literal">File</code> as follows:
                </p><pre class="programlisting">    File f = ...
    String response = r.post(String.class, f);</pre><p>
                Refer to the
                    <a class="ulink" href="https://maven.java.net/service/local/artifact/maven/redirect?r=snapshots&amp;g=com.sun.jersey.samples&amp;a=jaxb&amp;v=1.12-SNAPSHOT&amp;c=project&amp;e=zip" target="_top">JAXB sample</a> to see how JAXB with XML and JSON can be utilized with the client API (more specifically, see the unit tests).
                </p>
            </div>
        </div>

        <div class="section" title="3.6.&nbsp;Adding support for new representations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e694"></a>3.6.&nbsp;Adding support for new representations</h2></div></div></div>
            
            <p>The support for new application-defined representations as Java types requires the
            implementation of the same provider-based interfaces as for the server side JAX-RS API, namely
                <a class="ulink" href="http://jsr311.java.net/nonav/javadoc/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader</a> and
                <a class="ulink" href="http://jsr311.java.net/nonav/javadoc/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter</a>,
                respectively, for request and response entities (or inbound and outbound representations). Refer to the
                <a class="ulink" href="https://maven.java.net/service/local/artifact/maven/redirect?r=snapshots&amp;g=com.sun.jersey.samples&amp;a=entity-provider&amp;v=1.12-SNAPSHOT&amp;c=project&amp;e=zip" target="_top">entity provider</a>
                sample for such implementations utilized on the server side.
            </p>
            <p>Classes or implementations of the provider-based interfaces need to be registered with a
            <code class="literal">ClientConfig</code> and passed to the <code class="literal">Client</code> for creation. The following
            registers a provider class <code class="literal">MyReader</code> which will be instantiated by Jersey:
            </p><pre class="programlisting">    ClientConfig cc = new DefaultClientConfig();
    cc.getClasses().add(MyReader.class);
    Client c = Client.create(cc);</pre><p>
            The following registers an instance or singleton of MyReader:
            </p><pre class="programlisting">    ClientConfig cc = new DefaultClientConfig();
    MyReader reader = ...
    cc.getSingletons().add(reader);
    Client c = Client.create(cc);</pre>
        </div>

        <div class="section" title="3.7.&nbsp;Using filters"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e706"></a>3.7.&nbsp;Using filters</h2></div></div></div>
            
            <p>Filtering requests and responses can provide useful functionality that is hidden from the
            application layer of building and sending requests, and processing responses. Filters can
            read/modify the request URI, headers and entity or read/modify the response status,
            headers and entity.</p>
            <p>
            The <code class="literal">Client</code> and <code class="literal">WebResource</code> classes extend from
            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/filter/Filterable.html" target="_top">Filterable</a>
            and that enables the addition of
            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/filter/ClientFilter.html" target="_top">ClientFilter</a>
            instances. A <code class="literal">WebResource</code> will inherit filters from its creator, which
            can be a <code class="literal">Client</code> or another <code class="literal">WebResource</code>.
            Additional filters can be added to a <code class="literal">WebResource</code> after it has been
            created. For requests, filters are applied in order, starting with inherited filters
            and followed by the filters added to the <code class="literal">WebResource</code>. All filters
            are applied in the order in which they were added. For responses, filters are applied
            in reverse order, starting with the <code class="literal">WebResource</code> filters and then
            moving to the inherited filters.
            For instance, in the following example the <code class="literal">Client</code> has two filters added,
            <code class="literal">filter1</code> and <code class="literal">filter2</code>, in that order, and the
            <code class="literal">WebResource</code> has one filter added, <code class="literal">filter3</code>:
            </p><pre class="programlisting">    ClientFilter filter1 = ...
    ClientFilter filter2 = ...
    Client c = Client.create();
    c.addFilter(filter1);
    c.addFilter(filter2);
    
    ClientFilter filter3 = ...
    WebResource r = c.resource(...);
    r.addFilter(filter3);</pre><p>
            After a request has been built the request is filtered by <code class="literal">filter1</code>,
            <code class="literal">filter2</code> and <code class="literal">filter3</code> in that order. After the response
            has been received the response is filtered by <code class="literal">filter3</code>,
            <code class="literal">filter2</code> and <code class="literal">filter1</code> in that order, before the
            response is returned.</p>
            <p>Filters are implemented using the &#8220;russian doll&#8221; stack-based pattern where a
            filter is responsible for calling the next filter in the ordered list of filters
            (or the next filter in the &#8220;chain&#8221; of filters).
            The basic template for a filter is as follows:
            </p><pre class="programlisting">    class AppClientFilter extends ClientFilter {
        public ClientResponse handle(ClientRequest cr) {
            // Modify the request
            ClientRequest mcr = modifyRequest(cr);
            // Call the next filter
            ClientResponse resp = getNext().handle(mcr);
            // Modify the response
            return modifyResponse(resp);
        }
    }</pre>
            <p>The filter modifies the request (if required) by creating a new
            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/ClientRequest.html" target="_top">ClientRequest</a>
            or modifying the state of the passed <code class="literal">ClientRequest</code> before calling the
            next filter. The call to the next request will return
            the response, a <code class="literal">ClientResponse</code>. The filter
            modifies the response (if required) by creating a new <code class="literal">ClientResponse</code>
            or modifying the state of the returned <code class="literal">ClientResponse</code>.
            Then the filter returns the modified response.
            Filters are re-entrant and may be called by multiple threads performing requests
            and processing responses.</p>
            <div class="section" title="3.7.1.&nbsp;Supported filters"><div class="titlepage"><div><div><h3 class="title"><a name="d4e740"></a>3.7.1.&nbsp;Supported filters</h3></div></div></div>
                
                <p>The Jersey Client API currently supports two filters:</p>
                <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                        <p>A GZIP content encoding filter,
                            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/filter/GZIPContentEncodingFilter.html" target="_top">GZIPContentEncodingFilter</a>.
                            If this filter is added then a request entity is compressed with the
                            <code class="literal">Content-Encoding</code>
                            of <code class="literal">gzip</code>, and a response entity if compressed with a
                            <code class="literal">Content-Encoding</code> of <code class="literal">gzip</code> is
                            decompressed. The filter declares an <code class="literal">Accept-Encoding</code>
                            of <code class="literal">gzip</code>.
                        </p>
                    </li><li class="listitem">
                        <p>A logging filter,
                            <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/jersey/com/sun/jersey/api/client/filter/LoggingFilter.html" target="_top">LoggingFilter</a>.
                            If this filter is added then the request and response headers as well as the entities are logged
                            to a declared output stream if present, or to <code class="literal">System.out</code> if not.
                            Often this filter will be placed at the end of the ordered list of
                            filters to log the request before it is sent
                            and the response after it is received.
                        </p>
                    </li></ol></div>
                <p>The filters above are good examples that show how to modify or read
                request and response entities. Refer to the
                    <a class="ulink" href="https://maven.java.net/service/local/artifact/maven/redirect?r=snapshots&amp;g=com.sun.jersey&amp;a=jersey-client&amp;v=1.12-SNAPSHOT&amp;e=jar" target="_top">source code</a>
                    of the Jersey client for more details.
                </p>
            </div>
        </div>

        <div class="section" title="3.8.&nbsp;Testing services"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e759"></a>3.8.&nbsp;Testing services</h2></div></div></div>
            
            <p>The Jersey client API was originally developed to aid the testing of the Jersey server-side, 
            primarily to make it easier to write functional tests in conjunction with the JUnit framework
            for execution and reporting. It is used extensively and there are currently over 1000 tests.</p>
            <p>Embedded servers, Grizzly and a special in-memory server, are utilized to deploy the
            test-based services. Many of the Jersey samples contain tests that utilize the client API to
            server both for testing and examples of how to use the API. The samples utilize Grizzly or
            embedded Glassfish to deploy the services.</p>
            <p>The following code snippets are presented from the single unit test
            <code class="literal">HelloWorldWebAppTest</code> of the
                <a class="ulink" href="https://maven.java.net/service/local/artifact/maven/redirect?r=snapshots&amp;g=com.sun.jersey.samples&amp;a=helloworld-webapp&amp;v=1.12-SNAPSHOT&amp;c=project&amp;e=zip" target="_top">helloworld-webapp</a>
                sample.
            The <code class="literal">setUp</code> method, called before a test is executed, creates an instance of
            the Glassfish server, deploys the application, and a <code class="literal">WebResource</code> instance
            that references the base resource:
            </p><pre class="programlisting">    @Override
    protected void setUp() throws Exception {
        super.setUp();

        // Start Glassfish
        glassfish = new GlassFish(BASE_URI.getPort());
        
        // Deploy Glassfish referencing the web.xml
        ScatteredWar war = new ScatteredWar(
            BASE_URI.getRawPath(), new File("src/main/webapp"),
            new File("src/main/webapp/WEB-INF/web.xml"),
            Collections.singleton(
                new File("target/classes").
                    toURI().toURL()));
        glassfish.deploy(war);
        
        Client c = Client.create();
        r = c.resource(BASE_URI);
    }</pre><p>
            The <code class="literal">tearDown</code> method, called after a test is executed,
            stops the Glassfish server.
            </p><pre class="programlisting">    @Override
   protected void tearDown() throws Exception {
        super.tearDown();
        glassfish.stop();
   }</pre>
            <p>The <code class="literal">testHelloWorld</code> method tests that the response
            to a <code class="literal">GET</code> request to the Web resource returns &#8220;Hello World&#8221;:
            </p><pre class="programlisting">    public void testHelloWorld() throws Exception {
       String responseMsg = r.path("helloworld").
           get(String.class);
       assertEquals("Hello World", responseMsg);
   }</pre><p>
            Note the use of the <code class="literal">path</code> method on the <code class="literal">WebResource</code> to
            build from the base <code class="literal">WebResource</code>.</p>
        </div>

        <div class="section" title="3.9.&nbsp;Security with Http(s)URLConnection"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e778"></a>3.9.&nbsp;Security with Http(s)URLConnection</h2></div></div></div>
            
            <div class="section" title="3.9.1.&nbsp;With Http(s)URLConnection"><div class="titlepage"><div><div><h3 class="title"><a name="d4e780"></a>3.9.1.&nbsp;With Http(s)URLConnection</h3></div></div></div>
            
            <p>The support for security, specifically HTTP authentication and/or cookie management 
            with <code class="literal">Http(s)URLConnection</code> is limited due to constraints in the API.
            There are currently no specific features or properties on the <code class="literal">Client</code> class that
            can be set to support HTTP authentication. However, since the client API, by default, utilizes
            <code class="literal">HttpURLConnection</code> or <code class="literal">HttpsURLConnection</code>,
            it is possible to configure system-wide
            security settings (which is obviously not sufficient for multiple client configurations).</p>
            <p>For HTTP authentication the <code class="literal">java.net.Authenticator</code> can
            be extended and statically registered. Refer to the
                <a class="ulink" href="http://docs.oracle.com/javase/6/docs/technotes/guides/net/http-auth.html" target="_top">Http authentication</a>
                document for more details.
            For cookie management the <code class="literal">java.net.CookieHandler</code> can be extended
            and statically registered. Refer to the
                <a class="ulink" href="http://docs.oracle.com/javase/6/docs/technotes/guides/net/http-cookie.html" target="_top">Cookie Management</a>
                document for more details.
            </p>
            <p>To utilize HTTP with SSL it is necessary to utilize the &#8220;https&#8221; scheme.
            For certificate-based authentication see the class
                <a class="ulink" href="http://jersey.java.net/nonav/apidocs/latest/jersey/com/sun/jersey/client/urlconnection/HTTPSProperties.html" target="_top">HTTPSProperties</a>
                for how to set <code class="literal">javax.net.ssl.HostnameVerifier</code> and
                <code class="literal">javax.net.ssl.SSLContext</code>.
            </p>
            </div>
            <div class="section" title="3.9.2.&nbsp;With Apache HTTP client"><div class="titlepage"><div><div><h3 class="title"><a name="d4e796"></a>3.9.2.&nbsp;With Apache HTTP client</h3></div></div></div>
            
            <p>The support for HTTP authentication and cookies is much better with the Apache HTTP 
            client than with <code class="literal">HttpURLConnection</code>.
            See the Java documentation for the package
                <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/contribs/jersey-apache-client/com/sun/jersey/client/apache/package-summary.html" target="_top">com.sun.jersey.client.apache</a>,
                <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/contribs/jersey-apache-client/com/sun/jersey/client/apache/config/ApacheHttpClientState.html" target="_top">ApacheHttpClientState</a> and
                <a class="ulink" href="http://jersey.java.net/nonav/apidocs/1.12-SNAPSHOT/contribs/jersey-apache-client/com/sun/jersey/client/apache/config/ApacheHttpClientConfig.html" target="_top">ApacheHttpClientConfig</a> for more details.
            </p>
            </div>
        </div>
    </div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="jax-rs.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="xml.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;Overview of JAX-RS 1.1&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;XML Support</td></tr></table></div></body></html>